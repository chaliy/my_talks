# Практический DDD в .NET #
* Чалый Михаил (mike@chaliy.name) *
* Старший программист, Just Applications Inc. *

* Рассмартиваються вопросы практичесого использования DDD в .NET. Будут затронуты вопросы хранения Доменной Мож

## Про доклад, про меня. ##

## Теория одним слайдом. ##

Ченить стандарное про ДДД.

### Что такое ДДД? ###

- Попытка сместить акценты с базы данных или интерфейса, в строну бизнес логики.
- Модный тренд, тренд в построении ЛОБ приложений. Скучных и ужасных ентерпрайз(корпоративных) приложений.
- Обьеденение данных и поведения.
	
### Зачем оно? ###

- Для моделирования часто изменяющейся логики. Трейдоф между часто изменяющейся логикой и часто изменяющимся шейпом данных.

### Анлоги или конкуренты. ###

- Анемичные модели
- АктивРекорд
		
## Практика ##

- Так получилось что вокруг ДДД образовалась, такая себе мифическая обстановка.
- Тут есть своя библия (Ерик Еванс). Книга которая обо всем. Но непонятно как ее использовать.
- А есть и Закон Божий, толкование Библии.

- Ортогональность, Хексагональность

### Проблема Персистанс Игноранса ###

- Это наверное самая извесная и самая глубоко обсасываемая тема.  За счет того что в ДДД базаданных вторична (один из адаптеров в терминах ортогональной архитектруры) появляються несколько несвойственных традиционным подходам проблем. Например нема идентификатора. Отсутвет вохзможность сделать селект (вы ограничены возможностями языка програмирования).

- Запуск приложения без БД.

#### ПОКО ####

- Чтонить про ПОКО
- Незабыть сказать что в ПОКО. К обозначает СЛР, а не С#.

#### Проблема идентификации сущностей ####

- Это даж не пролема. В ДДД сущности должны быть ПОКО. А это обозначает что никаких идентификаторов из базы данных. Отсутвие идентификаторов обьясняеться просто. В ДДД моделируються реальные сущности. А у реальных сущностей всегда есть уникалный натйральный идентификатор. У Накладных - номер, у Контрагентов - ИНН, у домов - адрес. Если идентификатора не сущетвует, то это не сущность. Это может быть ВальюОбьектом или ДоменнымЕвентом(Еванс).
- Правила хорошего тона в ДДД подразумевают полное отсутвие идентификатора базы данных. Идентификатор роявляеться не раньше чем в инраструктуре. Освременные ОРМ позволяют это реализовать (это небольшое передергивание, так как я знаю то НХибирнейт который умеет это делать).
- Надо не забыть добавить что иногда это правило можно попрать. Например мы сначала следовали этому правилу, так клиенту передавался только натуральный идентификатор. А потом надоело. И у клиента главным идентификатором стал идентификатор базы данных (незабыть расказать нафика).

### Проблема валидации ###

- Под валидацией, я подразумеваю такие вещи как Имя Контрагента не должно быть больше 56 символов и там не должно быть буквы "Ъ".
- Собсно такая валидация вообще не ответвенность модели. Для модели важно что это строка. И все.
- Прямая ответсвенность за валидацию лежит на интерфейсе (будь то юзерский графический интрфейс или веб сервис). Расказать про наш путь с валидаторами в АСП.НЕТ(а так как у нас этого еще нема, то как минимум попробовать).
- В большенстве ситуаций длину в 56 символов также фикисируют и в базе данных, реально смысла это не имеет. Просто разрешите 450 символов.

### ЮнитОфВорк, нафига и где?

- Довольно редко в опреации учавствует одина строка. Обычно их много. И по попнятным причинам хотелось бы что бы операция была атомарна. Класичесоке решение это транзакция.
- После того как сказал слово транзакция, задумался нафика вообще тогда нужен этот ЮнитОфВорк.... *почитать!*

### Развесистые обьекты, большие модели ###

- В жизни очень легко строить большие иерархии, например у организации есть подразделения, у подразделений группы, у групп люди, у людей компы и так далее. Ессно возникает желание отобразить это все в обьектной модели. Все бы ничего если бы модель не была слишком развесистой.
- Технически существуют средства для решения этой проблемы, например лейзи лоад.
- Лейзи лоад - это когда у класа Организация есть коллекция Подразделений. Подразделения загружаються только в момент обращения к подразделениям.  Как и с другой технологией скрывающей реальность с это связано несколько проблем.
- Проблема Селект Н+1 (обьяснить что это за фигня) и проблема подгрузки васего домена в память (например с сериализацией и сумму всех накладных для контрагента).
- несколько поддеревьев
- типа введения каких-то weak references и прочего

### Проблема репортинга ###

- Очень часто модель не соответствует тому что хотечеться показать. Например хочеться показать агрегированные данные из разных контекстов. Или надо посчитать что-то информационное (типа у нас 300 контрагентов и 3489 накладных).
- Одно из решений это применение принципа CQS(Command Query Separation) на уровне дизайна. В упрощенном виде это разнесение выборки (Query) и изменения (Command) по разным полностью независимым копонентам.
- Мы например используем НХиб для изменения модели, а АДО.НЕТ Дата Сервисес, для показа.

### Проблема меж контекстового общения ###

- Например контекст Продаж, в нем есть Накладная, есть контекст CRM с Контрагентами. Как реализовать сценарий когда после 100 Накладных, Контрагент становиться Спамером?
- Один из способов это Доменные Сервисы. Это класс Модели, который представляет собой одну операцию. Факт того что Контрагент становиться Спамером можно установить например при создании Накладной. Соотвевенно появляеться операция СоздатьНакладную, в котором и происходит весь меджик.
- Выглядит знакомо? Очень похоже на слой бизнес логики в стандатной трех слойной архитектуре. На самом же деле это не совсем так. Это проще всего показать в коде.
	- Операция происходит на уже созданных обьектах.
	- Операция не сохраняет обьекты, в хранилище. Это позволяет писать очень лакончиный тестовый код.
- Проблема Доменных Сервисов, *выковырять из блога*
-- Доменные сервисы размазываюь логику, так например есть ОрдерСервис и сам Ордер. Тоесть уже как минимум два места работы с Ордером. Это усложняет использование домена.
-- Доменные сервисы болеют теми же проблемами что менеджеры. Тоесть у вас есть сервис, у него есть зависимости, эти зависимости со временем имеют свойство, разрастаться. Типа ботлнек.
-- Тестируемость. В отличии от домена, эти сервисы тестируються относительно сложно. ПРиходиться делать моки и тому подобное.
- Подход который мне нравиться болше это Доменные Евенты. *Расказать про евенты*.
-- 

### Проблема левых зависимостей ###

- Представте себе ситуацию. Когда Контрагент становиться Спамером, мы доджны его ответно заспамить. Проблема в том что нам надо тестировать Контрагента. А это обозначает что Контрагента надо как-то изолировать от отсылки спама.
- Одно из решений это ДепенденсиНнжекшен. Так в Доменный обьетк инжектиться ОтылаторСпама. И как будтобы все в шиколаде. На самом же деле проблемы тока начинаються. Самая глупая это то что наш домен теперь завист от ИоК контейнера. Тоесть вы не можете больше юзать конструкторы. Другая проблема это ненжуное усложнение доменного обьекта. Ну и третяя это нарушение SRP.
- Большенство проблем может решить Доменные Евенты. Обьекту не надо знать про ИоК. Ему просто надо зафаирить евент. Обработка события теперь происходит в специальном классе, таким макаром решаеться проблема усложнения и SRP. 

### Куча конфигурации ОРМ ###

- Проблема заключаеться в том что кроме доменной моедли приходится потдерживать еще и мапинги этих обьектов в базу данных. Со временем, это начинает надоедать. Решение это использование конвеншенов.
- Первое это тулзы на подобие FluentNHibernate
- Свои генераторы. Например Т4.

### Какие ОРМ можно юзать ###

- Любые, но проблема в том сока вы потратитет время на потдержку.
- ЕнтитиФремворк - пока что судить сложно, но она уже не потдердживает ряд ключевых моментов. Например отсутвует возможность работать без идентификатора. Отсутвует возможность спрятать системные свойства(Аудит, Конкурентность).
- НХибирнейт, имеет решения для большенмтва проблем.

### Производительность ###

- В ДДД на производилеьность отрицательно влияет несколько фишек.
- Обьект загружаеться полностью, все поля, иногда даже с детишками. Понятно что тяжеловесного говна там может быть просто нереально много.
- Когда надо присвоить Счету, Контрагента. То приходиться подымать и Контрагента.
- Игонрировать производительность неззя. Пока что.
- Так например если ожидаеться большое количество данных, например картинка, то возможно ее надо сделть отдельной сущностью, и подгружать лейзи.
- Во всю использовать CQS, наша статистика это большая часть работы это таки просмотр.
- Реально оценивать проблемвы с производительностью (например в датацентрик перед присвением Контрагента Счету всеравно надо проверить идентификатор, тоесть все равно есть запрос).

### Кеширование и фармы ###

- Наверное самым удобным для програмиста бы было если бы вся модель была бы в памяти, в одном процесе. В реальности это не так.
- Мы пока что стратегически не используем кеш.
- Непродуманый обьектный кеш не работает на фарме. А например разделение по тенантам, да. Или разделение по сервисам.
- Другое решение это все тот же CQS, кешить результаты репортов вполне может себе хорошим решением.
- Кешить результаты.

### Общение между слоями ###

- AutoMapper

### DDDD ###

### Ссылки ###

http://dddsample.sourceforge.net/ - Пример на java
http://www.domaindrivendesign.org/ - Просто так
http://tech.groups.yahoo.com/group/domaindrivendesign/ - дискусионная группа
http://github.com/MarkNijhof/Fohjin - Пример DDDD на .NET

### Книги ###

Domain-Driven Design: Tackling Complexity in the Heart of Software, Eric Evans
Domain Driven Design Quickly, Eric Evans
Applying Domain-Driven Design and Patterns: With Examples in C# and .NET, Jimmy Nilsson 


[1]: http://weblogs.asp.net/arturtrosin/archive/2009/02/09/domain-driven-design-learning.aspx
[2]: http://code.google.com/p/ndddsample/
